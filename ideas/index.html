<body>
<canvas id="mCanvas">
</canvas>
</body>
<script src="https://threejs.org/build/three.js"></script>
<script>
    // Var Init
    var renderer, scene, camera, box, transformControl, orbitControl, geometry, material, poseMatrix;
    var mPoints = [];
    //Box coordinate
    var xBCordinate, yBCordinate, zBCordinate, isScaled, posVec, startPosVec, lookPos, helper;
    var process = false;
    var scanActive = false;
    var pointArr = [];
    var clk = new THREE.Clock();

    var cameraSpherical;
    let secClk = 0;

    init();
    animate();
    // movement - please calibrate these values
    var xSpeed = 0.0001;
    var ySpeed = 0.0001;

    let prevPosition = [.5,.5,0.];
    let prevDir = 5;

    function init() {

        // renderer
        renderer = new THREE.WebGLRenderer({canvas: document.getElementById("mCanvas"),
            alpha: true});
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
        renderer.setClearColor(0xffffff, 0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // scene
        scene = new THREE.Scene();

        // camera
        camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );

        camera.up.set(0, 0, 1); // Definition of coordinationsystem

        // set initial scale position of camera
        camera.position.x = 0;
        camera.position.y = -0.5;
        camera.position.z = 0.15;

        scene.add(camera);

        cameraSpherical = new THREE.Spherical( camera.position );

        // set position to look at
        camera.lookAt(0,2.5,-0.2);

        // apply values
        camera.updateMatrix();

        // light
        var light = new THREE.HemisphereLight( 0xeeeeee, 0x888888, 1 );
        light.position.set( 0, -0.75, 2.5 );
        scene.add(light);


        placeBox();

    }
    function placeBox()
    {


        geometry = new THREE.BoxGeometry(1, 1, 1); //3,5,3
        material = new THREE.MeshLambertMaterial({color: '#de2727'});

        box = new THREE.Mesh(geometry, material);

        box.position.set(0, 0, .51);
        box.updateMatrix();
        scene.add(box);

    }

    document.addEventListener("keydown", onDocumentKeyDown, false);
    function onDocumentKeyDown(event) {
        var keyCode = event.which;
        if (keyCode == 87) {
            box.position.y += 1;
        } else if (keyCode == 83) {
            box.position.y -= 1;
        } else if (keyCode == 65) {
            box.position.x -= 1;
        } else if (keyCode == 68) {
            box.position.x += 1;
        } else if (keyCode == 32) {
            box.position.set(0, 0, 0);
        }
    };

    function placePath()
    {
        let dir = Math.floor(getRandomFloat(0,7));
        geometry = new THREE.PlaneGeometry(1,1);
        const material = new THREE.MeshBasicMaterial( {color: '#349ee5', side: THREE.DoubleSide} );
        const plane = new THREE.Mesh( geometry, material );

        scene.add( plane );

        geometry.translate.x = prevPosition[0];
        geometry.translate.y = prevPosition[1];
        geometry.translate.z = prevPosition[2];

        switch(dir)
        {
            case 0: // UP
                console.log("UP");
                geometry.rotateX(Math.PI / 2);
                geometry.translateX(.5)
                break;
            case 1: // DOWN
                console.log("DOWN");
                geometry.rotateX(Math.PI / 2);
                break;
            case 2: // LEFT
                console.log("LEFT");
                break;
            case 3: // RIGHT
                console.log("RIGHT");
                break;
            default:
                console.log("FORWARD");
                break;
        }

        var posX = box.position.x;
    }

    function updatePath()
    {
        let delta = clk.getElapsedTime();
        //box.translateY(Math.sin(delta) /20);
        if (delta > secClk) {
            secClk += 1;
            console.log("placing path...");
            placePath();
        }
        //console.log(delta);
    }

    function animate() {
        updatePath();
        requestAnimationFrame(animate);
        if(process == false){
            setCurrentPose();

        }

        renderer.render(scene, camera);
    }

    function setCurrentPose(){
        process = true;

        // this is where I receive the position data via Android
        // but lets try using random numbers between 0.01 - 0.99 (which are the results interval of dso)

        moveRotateCamera();
    }
    function moveRotateCamera(){
        // Create Vector to work with
        /* posVec = new THREE.Vector3();

         posVec.x = getRandomFloat(0.01, 0.05);
         posVec.y = getRandomFloat(0.01, 0.05);
         posVec.z = getRandomFloat(0.01, 0.02);


          camera.position.x += posVec.x;
          camera.position.y += posVec.y; // minus initial scale position
          camera.position.z += posVec.z;
          */
        cameraSpherical.radius = 5;
        cameraSpherical.phi += .005;
        cameraSpherical.theta += .002;
        let xyz = new THREE.Vector3().setFromSpherical( cameraSpherical );
        camera.position.x = xyz.x;
        camera.position.y = xyz.y;
        camera.position.z = xyz.z;

        camera.lookAt(0,0,0);

        camera.updateMatrix();



        //   camera.updateMatrix(); <- seem to change nothing such as UpdateWorldMatrix() etc.

        // camera rotation tried to calculate with quaternions (result NaN) and/or euler by using former and current point.
        process = false;
    }
    function getRandomFloat(min, max) {
        return Math.random() * (max - min) + min;
    }


    // My attempts in trying to calculate the rotation
    /*
    function setQuaternionRotation(poseMatrix){
            // TODO: delete if not needed!
            // adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm, 2.12.2019, 2.34pm
            mQuaternion = new THREE.Quaternion();

            // Calculate Angle w
            mQuaternion.w = ((Math.sqrt(Math.max(0, (1.0 + poseMatrix.elements[0] + poseMatrix.elements[5] + poseMatrix.elements[10])))/2.0));

            //Sign x,y,z values of quaternion
            mQuaternion.x = ((Math.sqrt(Math.max(0, (1.0 + poseMatrix.elements[0] - poseMatrix.elements[5] - poseMatrix.elements[10])))/2.0));
            mQuaternion.y = ((Math.sqrt(Math.max(0, (1.0 - poseMatrix.elements[0] + poseMatrix.elements[5] - poseMatrix.elements[10])))/2.0));
            mQuaternion.y = ((Math.sqrt(Math.max(0, (1.0 - poseMatrix.elements[0] - poseMatrix.elements[5] + poseMatrix.elements[10])))/2.0));

            //Sign element values
            mQuaternion.x = (Math.sign(mQuaternion.x * (poseMatrix.elements[6] - poseMatrix.elements[9])));
            mQuaternion.y = (Math.sign(mQuaternion.y * (poseMatrix.elements[8] - poseMatrix.elements[2])));
            mQuaternion.z = (Math.sign(mQuaternion.z * (poseMatrix.elements[1] - poseMatrix.elements[4])));

            // debug
            console.log("QuaternionVal: "+mQuaternion.x+ ", " +mQuaternion.y+", "+mQuaternion.z+", "+mQuaternion.w);

            camera.applyQuaternion(mQuaternion);
            camera.quaternion.normalize();


            // debug
            console.log("newCamRotation: "+camera.rotation.x +", "+camera.rotation.y+", "+ camera.rotation.z);

       //     camera.updateMatrix(true);
        }

    */
</script>