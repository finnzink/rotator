<div id="info"><p id="p1">Hello World!</p></div>
<body>
<canvas id="mCanvas">
</canvas>
</body>
<script src="https://threejs.org/build/three.js"></script>
<script>
    // Var Init
    var renderer, scene, camera, box, transformControl, orbitControl, geometry, material, poseMatrix;
    var mPoints = [];
    //Box coordinate
    var xBCordinate, yBCordinate, zBCordinate, isScaled, posVec, startPosVec, lookPos, helper;
    var process = false;
    var scanActive = false;
    var pathArr = [];
    var clk = new THREE.Clock();

    var cameraSpherical;
    let secClk = 0;
    let straightSegs = -1;
    let currDir = new THREE.Vector3(1, 0, 0);
    let upDir = new THREE.Vector3(0, 0, 1);

    let boxCurrDir = new THREE.Vector3(0, 1, 0);
    let boxUpDir = new THREE.Vector3(0, 0, 1);
    let boxFinalPos = new THREE.Vector3(0, 0, .51);

    let boxIsMoving = 0;
    let score = 0;
    let isDead = 0;

    init();
    animate();
    // movement - please calibrate these values
    var xSpeed = 0.0001;
    var ySpeed = 0.0001;

    document.addEventListener("keydown", onDocumentKeyDown, false);
    function onDocumentKeyDown(event) {
        var keyCode = event.which;
        if (keyCode == 87) {
            // UP

        } else if (keyCode == 83) {
            //DOWN

        } else if (keyCode == 65 && !boxIsMoving) {
            boxCurrDir.applyAxisAngle(boxUpDir, Math.PI/2);
            boxCurrDir.x = Math.round(boxCurrDir.x);
            boxCurrDir.y = Math.round(boxCurrDir.y);
            boxFinalPos.add(boxCurrDir.multiplyScalar(5));
            boxCurrDir.multiplyScalar(.2);
            boxIsMoving = 1;

        } else if (keyCode == 68 && !boxIsMoving) {
            boxCurrDir.applyAxisAngle(boxUpDir, -Math.PI/2);
            boxCurrDir.x = Math.round(boxCurrDir.x);
            boxCurrDir.y = Math.round(boxCurrDir.y);
            boxFinalPos.add(boxCurrDir.multiplyScalar(5));
            boxCurrDir.multiplyScalar(.2);
            boxIsMoving = 1;

        } else if (keyCode == 32) {
            box.position.set(0, 0, 0);
        }
    };

    function init() {

        // renderer
        renderer = new THREE.WebGLRenderer({canvas: document.getElementById("mCanvas"),
            alpha: true});
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
        renderer.setClearColor(0xffffff, 0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // scene
        scene = new THREE.Scene();

        // camera
        camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );

        camera.up.set(0, 0, 1); // Definition of coordinationsystem

        // set initial scale position of camera
        camera.position.x = 10;
        camera.position.y = 10;
        camera.position.z = 10;

        scene.add(camera);

        // change this to quaternion?
        cameraSpherical = new THREE.Spherical( camera.position );

        // set position to look at
        camera.lookAt(0,0,0);

        // apply values
        camera.updateMatrix();

        // light
        var light = new THREE.HemisphereLight( 0xeeeeee, 0x888888, 1 );
        light.position.set( 0, -0.75, 2.5 );
        scene.add(light);

        geometry = new THREE.PlaneGeometry(1,1);
        const material = new THREE.MeshBasicMaterial( {color: '#349ee5', side: THREE.DoubleSide} );
        const plane = new THREE.Mesh( geometry, material );

        scene.add(plane);
        pathArr.push(plane)

        placeBox();

    }

    function placeBox()
    {


        geometry = new THREE.BoxGeometry(1, 1, 1); //3,5,3
        material = new THREE.MeshLambertMaterial({color: '#de2727'});

        box = new THREE.Mesh(geometry, material);

        box.position.set(0, 0, .51);
        box.updateMatrix();
        scene.add(box);

    }

    function addPath() {
        //let relativeDir = Math.floor(getRandomFloat(0,4));
        geometry = new THREE.PlaneGeometry(1, 1);
        const material = new THREE.MeshBasicMaterial({color: '#349ee5', side: THREE.DoubleSide});
        const plane = new THREE.Mesh(geometry, material);

        let prevPlane = pathArr[pathArr.length - 1];
        if (pathArr.length > 16) {
            // check if dead
            let centerPt = new THREE.Vector3;
            box.getWorldPosition(centerPt);
            let pathPt = new THREE.Vector3;
            pathArr[0].getWorldPosition(pathPt);
            if (centerPt.x == pathPt.x && centerPt.y == pathPt.y) {
                console.log(centerPt);
                score = 0;
                document.getElementById("p1").innerHTML = "too slow. RIP";
                isDead = 1;
            }

            scene.remove(pathArr[0]);
            pathArr.shift();
        }

        let centerPt = new THREE.Vector3;
        prevPlane.getWorldPosition(centerPt);

        plane.translateX(centerPt.x + currDir.x);
        plane.translateY(centerPt.y + currDir.y);
        plane.translateZ(centerPt.z + currDir.z);

        scene.add( plane );
        pathArr.push(plane);
    }

    function placePath() {


        //console.log(centerPt)

        // TRANSFORM PATH HERE
        let nextDir = Math.floor(2*Math.random());
        if (straightSegs < 4) {
            addPath();
            straightSegs++;
        }
        // TURN LEFT
        else if (nextDir == 0) {
            console.log("LEFT")
            currDir.applyAxisAngle(upDir, Math.PI/2);
            currDir.x = Math.round(currDir.x);
            currDir.y = Math.round(currDir.y);
            addPath();
            straightSegs = 0;
        }
        // TURN RIGHT
        else if (nextDir == 1){
            console.log("RIGHT")
            currDir.applyAxisAngle(upDir, -Math.PI/2);
            currDir.x = Math.round(currDir.x);
            currDir.y = Math.round(currDir.y);
            addPath();
            straightSegs = 0;
        }


    }

    function updatePath()
    {
        let delta = clk.getElapsedTime();
        if (pathArr.length < 12) {
            placePath();
        }
        if (delta > secClk && !isDead) {
            secClk += 1;
            placePath();
        }
        //console.log(delta);
    }

    function animate() {
        updatePath();
        moveRotateCamera();
        animateCube();
        requestAnimationFrame(animate);

        renderer.render(scene, camera);
    }

    function setCurrentPose(){
        process = true;

        // this is where I receive the position data via Android
        // but lets try using random numbers between 0.01 - 0.99 (which are the results interval of dso)


    }

    function animateCube() {
        let centerPt = new THREE.Vector3;
        box.getWorldPosition(centerPt);
        //console.log(centerPt);
        let pathPt = new THREE.Vector3;
        if (! centerPt.equals(boxFinalPos)){
            box.translateX(boxCurrDir.x);
            box.translateY(boxCurrDir.y);
        }
        else if (boxIsMoving) {
            // CHECK IF DEAD
            boxIsMoving = 0;
            for (let i = 0; i < pathArr.length; i++) {
                pathArr[i].getWorldPosition(pathPt);
                if (pathPt.x == centerPt.x && pathPt.y == centerPt.y) {
                    //console.log("SAFE");
                    score += 1;
                    document.getElementById("p1").innerHTML = "Score: " + score.toString();
                    // color path
                    for (let j = 0; j <= i; j++) {
                        pathArr[j].material.color.set('#000000');
                    }
                    return;
                }
            }
            // DEAD
            score = 0;
            document.getElementById("p1").innerHTML = "you fell off the path. RIP";
            isDead = 1;
        }
    }
    function moveRotateCamera(){
            let centerPt = new THREE.Vector3;
            pathArr[pathArr.length - 1].getWorldPosition(centerPt);

            camera.position.x = centerPt.x + 10;
            camera.position.y = centerPt.y - 10;
            camera.position.z = centerPt.z + 10;

            camera.lookAt(centerPt.x, centerPt.y, centerPt.z);
    }

</script>